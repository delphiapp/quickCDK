unit qCDK103types;

interface

uses Classes,SysUtils;

const
////////// данные константы используются для описания свойств классов-помощников
  ndxMilliseconds=0;      ndxMinutes=1;
  ndxRES1=2;              ndxIV=3;
  ndxHours=4;             RES2=5;
  ndxSU=6;
  ndxDayOfMonth=7;        ndxDayOfWeek=8;
  ndxMonth=9;             ndxYear=10;
  ndxRES4=11;

  ndxTP=12; ndxTM=13; ndxTEST=14; ndxOTEV=15;

  ndxFCV=100; ndxFCB=101; ndxPRM=102; ndxRES=103;
  ndxDFC=100; ndxACD=101;
//////////

////////// константы ошибок, дополняют список в uConnections
  iecePosAck=100;                     // положительное подтверждение
  ieceNegAck=101;                     // отрицательное подтверждение
  ieceBroadCast=102;                  // широковещательная посылка
  ieceUserData=108;                   // есть пользовательские данные
  ieceNoUserData=109;                 // нет пользовательских данных
  ieceChannelState=111;               // состояние канала связи
  ieceServiceUnavailable=114;         // сервис не доступен
  ieceServiceUnimplemented=115;       // сервис не реализован

  ieceControlFunctionCode=-100;       // код функции неизвестен (или не реализован в данной версии протокола)
  ieceLinkControlField=-101;          // ожидается поле управления
  ieceLinkAddress=-102;               // ожидается адрес устройства
  ieceTypeIdentification=-103;        // ожидается идентификатор типа
  ieceTypeIdentificationUnknown=-104; // идентификатор типа неизвестен (или не реализован в данной версии протокола)
  ieceVariableStructureQualifier=-105;// ожидается классификатор переменной стуктуры (7.2.2)
  ieceCauseOfTransmission=-106;       // ожидается причина передачи COT (7.2.3)
  ieceASDUAddress=-107;               // ожидается ASDU адрес (7.2.4)
  ieceFunctionType=-108;              // ожидается тип функции FUN (7.2.5.1)
  ieceInformationNumber=-109;         // ожидается номер информации INF (7.2.5.2)

  ieceCP56Time2a=-115;                // ожидается время типа CP56Time2a (7.2.6.29)
  ieceSCN=-116;                       // ожидается номер сканирования SCN (7.2.6.21)
  ieceDCO=-117;                       // ожидается значение двухпозиционной команды DCO (7.2.6.4)
//  ieceDCOinvalid=29;                  // неверное значение двухпозиционной команды DCO (7.2.6.4)
  ieceRII=-119;                       // ожидается идентификатор возвращаемой информации RII (7.2.6.19)
  ieceTOO=-120;                       // ожидается тип приказа TOO (7.2.6.26)
  ieceTOV=-121;                       // ожидается тип аварийных значений TOV (7.2.6.27)
  ieceFAN=-122;                       // ожидается номер повреждения FAN (7.2.6.6)
  ieceACC=-123;                       // ожидается номер канала ACC (7.2.6.1)
  ieceDPI=-124;                       // ожидается двухэлементная информация DPI (7.2.6.5)
  ieceCP32Time2a=-125;                // ожидается время типа CP32Time2a (7.2.6.28)
  ieceSIN=-126;                       // ожидается значение дополнительной информации SIN (7.2.6.23)
  ieceRET=-127;                       // ожидается относительное время RET (7.2.6.15)
  ieceMEA=-128;                       // ожидается значение измеряемой величины MEA (7.2.6.8)
  ieceSCL=-129;                       // ожидается расстояние до места короткого замыкания (7.2.6.20)
  ieceCOL=-130;                       // ожидается уровень совместимости COL (7.2.6.3)
  ieceASC=-131;                       // ожидается символ идентификации ASC (7.2.6.2)
  ieceSoftwareID=-132;                // ожидается байт внутреннего идентификатора программного обеспечения
  ieceSOF=-133;                       // ожидается состояние повреждения SOF (7.2.6.24)
  ieceNullByte=-134;                  // ожидается байт со значением 0
  ieceNOF=-135;                       // ожидается номер повреждения сети NOF (7.2.6.12)
  ieceNOC=-136;                       // ожидается число каналов NOC (7.2.6.10)
  ieceNOE=-137;                       // ожидается число элементов информации в канале NOE (7.2.6.11)
  ieceINT=-138;                       // ожидается интервал между элементами в канале INT (7.2.6.7)
  ieceRPV=-139;                       // ожидается номинальное первичное значение RPV (7.2.6.17)
  ieceRSV=-140;                       // ожидается номинальное вторичное значение RSV (7.2.6.18)
  ieceRFA=-141;                       // ожидается масштабный коэффициент RFA (7.2.6.16)
  ieceNOT=-142;                       // ожидается число меток NOT (7.2.6.13)
  ieceTAP=-143;                       // ожидается положение метки TAP (7.2.6.25)
  ieceNDV=-144;                       // ожидается число аварийных значений NDV (7.2.6.14)
  ieceNFE=-145;                       // ожидается номер первого элемента информации NFE (7.2.6.9)
  ieceSDV=-146;                       // ожидается одиночное аварийное значение SDV (7.2.6.22)

  lwIEC103ErrorsCount=49;
  IEC103ErrorsInfos:array[0..lwIEC103ErrorsCount-1]of TIdentMapEntry=(
    (Value:iecePosAck;                          Name:'100 - положительное подтверждение'),
    (Value:ieceNegAck;                          Name:'101 - отрицательное подтверждение'),
    (Value:ieceBroadCast;                       Name:'102 - широковещательная посылка'),
    (Value:ieceUserData;                        Name:'108 - есть пользовательские данные'),
    (Value:ieceNoUserData;                      Name:'109 - нет пользовательских данных'),
    (Value:ieceChannelState;                    Name:'111 - состояние канала связи'),
    (Value:ieceServiceUnavailable;              Name:'114 - сервис не доступен'),
    (Value:ieceServiceUnimplemented;            Name:'115 - сервис не реализован'),

    (Value:ieceControlFunctionCode;             Name:'-100 - код функции неизвестен (или не реализован в данной версии протокола)'),
    (Value:ieceLinkControlField;                Name:'-101 - ожидается поле управления'),
    (Value:ieceLinkAddress;                     Name:'-102 - ожидается адрес устройства'),
    (Value:ieceTypeIdentification;              Name:'-103 - ожидается идентификатор типа'),
    (Value:ieceTypeIdentificationUnknown;       Name:'-104 - идентификатор типа неизвестен (или не реализован в данной версии протокола)'),
    (Value:ieceVariableStructureQualifier;      Name:'-105 - ожидается классификатор переменной стуктуры (7.2.2)'),
    (Value:ieceCauseOfTransmission;             Name:'-106 - ожидается причина передачи COT (7.2.3)'),
    (Value:ieceASDUAddress;                     Name:'-107 - ожидается ASDU адрес (7.2.4)'),
    (Value:ieceFunctionType;                    Name:'-108 - ожидается тип функции FUN (7.2.5.1)'),
    (Value:ieceInformationNumber;               Name:'-109 - ожидается номер информации INF (7.2.5.2)'),

    (Value:ieceCP56Time2a;                      Name:'-115 - ожидается время типа CP56Time2a (7.2.6.29)'),
    (Value:ieceSCN;                             Name:'-116 - ожидается номер сканирования SCN (7.2.6.21)'),
    (Value:ieceDCO;                             Name:'-117 - ожидается значение двухпозиционной команды DCO (7.2.6.4)'),
    (Value:ieceRII;                             Name:'-119 - ожидается идентификатор возвращаемой информации RII (7.2.6.19)'),
    (Value:ieceTOO;                             Name:'-120 - ожидается тип приказа TOO (7.2.6.26)'),
    (Value:ieceTOV;                             Name:'-121 - ожидается тип аварийных значений TOV (7.2.6.27)'),
    (Value:ieceFAN;                             Name:'-122 - ожидается номер повреждения FAN (7.2.6.6)'),
    (Value:ieceACC;                             Name:'-123 - ожидается номер канала ACC (7.2.6.1)'),
    (Value:ieceDPI;                             Name:'-124 - ожидается двухэлементная информация DPI (7.2.6.5)'),
    (Value:ieceCP32Time2a;                      Name:'-125 - ожидается время типа CP32Time2a (7.2.6.28)'),
    (Value:ieceSIN;                             Name:'-136 - ожидается значение дополнительной информации SIN (7.2.6.23)'),
    (Value:ieceRET;                             Name:'-127 - ожидается относительное время RET (7.2.6.15)'),
    (Value:ieceMEA;                             Name:'-128 - ожидается значение измеряемой величины MEA (7.2.6.8)'),
    (Value:ieceSCL;                             Name:'-129 - ожидается расстояние до места короткого замыкания (7.2.6.20)'),
    (Value:ieceCOL;                             Name:'-130 - ожидается уровень совместимости COL (7.2.6.3)'),
    (Value:ieceASC;                             Name:'-131 - ожидается символ идентификации ASC (7.2.6.2)'),
    (Value:ieceSoftwareID;                      Name:'-132 - ожидается байт внутреннего идентификатора программного обеспечения'),
    (Value:ieceSOF;                             Name:'-133 - ожидается состояние повреждения SOF (7.2.6.24)'),
    (Value:ieceNullByte;                        Name:'-134 - ожидается байт со значением 0'),
    (Value:ieceNOF;                             Name:'-135 - ожидается номер повреждения сети NOF (7.2.6.12)'),
    (Value:ieceNOC;                             Name:'-136 - ожидается число каналов NOC (7.2.6.10)'),
    (Value:ieceNOE;                             Name:'-137 - ожидается число элементов информации в канале NOE (7.2.6.11)'),
    (Value:ieceINT;                             Name:'-138 - ожидается интервал между элементами в канале INT (7.2.6.7)'),
    (Value:ieceRPV;                             Name:'-139 - ожидается номинальное первичное значение RPV (7.2.6.17)'),
    (Value:ieceRSV;                             Name:'-140 - ожидается номинальное вторичное значение RSV (7.2.6.18)'),
    (Value:ieceRFA;                             Name:'-141 - ожидается масштабный коэффициент RFA (7.2.6.16)'),
    (Value:ieceNOT;                             Name:'-142 - ожидается число меток NOT (7.2.6.13)'),
    (Value:ieceTAP;                             Name:'-143 - ожидается положение метки TAP (7.2.6.25)'),
    (Value:ieceNDV;                             Name:'-144 - ожидается число аварийных значений NDV (7.2.6.14)'),
    (Value:ieceNFE;                             Name:'-145 - ожидается номер первого элемента информации NFE (7.2.6.9)'),
    (Value:ieceSDV;                             Name:'-146 - ожидается одиночное аварийное значение SDV (7.2.6.22)')
  );

////////// описание поля управления
  iUnused=7;
{
  Link Control Field - поле управления

  MSB                LSB
   7   6   5   4   3..0
  RES PRM FCB FCV Код_функции

  RES - резерв

  PRM = 1  -  для управляющего (control direction), первичная станция, сообщение от первичной станции к вторичной

  FCB - бит счёта кадров, чередующиеся 0 и 1 при последовательных передачах ПОСЫЛКА/ПОДТВЕРЖДЕНИЕ или ЗАПРОС/ОТВЕТ
  если ожидаемый ответ отсутствует или искажается, то ПОСЫЛКА/ПОДТВЕРЖДЕНИЕ или ЗАПРОС/ОТВЕТ повторяется с тем же FCB

  при команде сброса бит FCB всегда равен 0, а после приёма этой команды вторичная станция всегда ожидает следующий кадр
  от первичной станции с FCV, равным 1, чтобы установить FCB=1

  FCV - законность бита счёта кадров:
  0 - изменение бита FCB неверно,   1 - верно

  Для процедуры ПОСЫЛКА/БЕЗ ОТВЕТА при циркулярных сообщениях и т.п. процедур, в которых не контролируются потери и дублирование
  сообщений, бит FCB не меняется, а нарушения указываются обнулением бита FCV


  MSB                LSB
   7   6   5   4   3..0
  RES PRM ACD DFC Код_функции

  PRM = 0  -  для управляемого (monitor direction), вторичная станция, сообщение от вторичной станции к первичной

  DFC - контроль потока данных:
  0 - приём сообщений возможен,   1 - приём сообщений невозможен из-за переполнения буфера

  ACD - бит требования запроса данных:
  0 - нет данных класса 1 на передачу,    1 - есть
}

////////// тип кадра Frame Type
// для первичной
  ft1SendAck=0;  // ПОСЫЛКА/ПОДТВЕРЖДЕНИЕ
  ft1Req=1;      // ЗАПРОС БЕЗ ОТВЕТА
  ft1ReqRes=2;   // ЗАПРОС/ОТВЕТ
// для вторичной
  ft2Ack=3;      // ПОДТВЕРЖДЕНИЕ, acknowledge
  ft2Res=4;      // ОТВЕТ, response
// должны вызывать исключение
  ftReserved=5;   // резерв
  ftNotUsed=6;    // не используется

////////// константы кодов функций управления Function Code
// для первичной
  fc1ResetCommUnit=0;
  fc1UserSend=3;                fc1UserBroadcast=4;
  fc1ResetFCB=7;                fc1ChannelState=9;
  fc1Class1=10;                 fc1Class2=11;
// для вторичной
  fc2PosAck=0;                  fc2NegAck=1;
  fc2UserData=8;                fc2NoUserData=9;
  fc2ChannelState=11;
  fc2ServiceUnavailable=14;     fc2ServiceUnimplemented=15;

////////// константы ASDU Type Identification
// для первичной
  ti1TimeSynchronization=6;             // синхронизация времени
  ti1GeneralInterrogation=7;            // общий опрос
  ti1GenericInfo=10;                    // групповая информация
  ti1GeneralCommand=20;                 // общая команда
  ti1GenericCommand=21;                 // групповая команда
  ti1FaultOrder=24;                     // приказ передачи данных о нарушениях (выбор нарушения, запрос/отмена передачи меток и данных аналоговых каналов)
  ti1FaultAcknowledge=25;               // подтверждение передачи данных о нарушениях - положительное или отрицательное
// для вторичной
  ti2TimeTag=1;                         // сообщение с меткой времени
  ti2RelativeTimeTag=2;                 // сообщение с меткой относительного времени
  ti2MeasuredValues1=3;                 // измеряемые величины, набор типа 1
  ti2ShortCircuitLocation=4;            // место короткого замыкания
  ti2IdentificationInfo=5;              // идентификационная информация
  ti2TimeSynchronization=6;             // синхронизация времени
  ti2GeneralInterrogationTermination=8; // завершение общего опроса
  ti2MeasuredValues2=9;                 // измеряемые величины, набор типа 2
  ti2GenericInfo=10;                    // групповая информация
  ti2GenericIdentifier=11;              // групповой идентификатор
  ti2FaultsList=23;                     // список зарегистрированных нарушений
  ti2FaultDataReady=26;                 // готовность к передаче данных о нарушениях
  ti2FaultChannelReady=27;              // готовность к передаче данных аналогового канала
  ti2FaultTagsReady=28;                 // готовность к передаче меток
  ti2FaultTagsTransmission=29;          // передача меток
  ti2FaultValuesTransmission=30;        // передача аварийных значений
  ti2FaultTransmissionTermination=31;   // завершение передачи данных о нарушениях

////////// константы причины передачи Cause Of Transmission
// для первичной
  cot1TimeSynchronization=8;            // синхронизация времени
  cot1GeneralInterrogation=9;           // инициализация общего опроса
  cot1GeneralCommand=20;                // общая команда
  cot1FaultTransmission=31;             // передача данных о нарушениях
  cot1GenericWriteCommand=40;           // групповая команда записи
  cot1GenericReadCommand=41;            // групповая команда чтения
// для вторичной
  cot2Sporadic=1;                       // спорадическая
  cot2Cyclic=2;                         // циклическая
  cot2ResetFCB=3;                       // сброс бита счёта кадров FCB
  cot2ResetCommUnit=4;                  // сброс подсистемы связи CU
  cot2StartRestart=5;                   // старт/рестарт
  cot2PowerOn=6;                        // включение питания
  cot2TestMode=7;                       // тестовый режим
  cot2TimeSynchronization=8;            // синхронизация времени
  cot2GeneralInterrogation=9;           // общий опрос
  cot2GeneralInterrogationTermination=10; // завершение общего опроса
  cot2LocalOperation=11;                // местная операция
  cot2RemoteOperation=12;               // удалённая операция
  cot2GeneralCommandPosAck=20;          // положительное подтверждение команды
  cot2GeneralCommandNegAck=21;          // отрицательное подтверждение команды
  cot2FaultDataTransmission=31;         // передача данных о неисправностях
  cot2GenericWriteCommandPosAck=40;     // положительное подтверждение групповой команды записи
  cot2GenericWriteCommandNegAck=41;     // отрицательное подтверждение групповой команды записи
  cot2GenericReadCommandValid=42;       // ответ правильными данными на групповую команду чтения
  cot2GenericReadCommandNotValid=43;    // ответ на групповую команду чтения данными, среди которых могут быть неправильные
  cot2GenericWriteAck=44;               // подтверждение групповой записи

////////// константы типа приказа для нарушений
// для первичной
  // для ASDU24
  too1FaultSelect=1;                    // выбор повреждения
  too1FaultDataRequest=2;               // запрос данных о нарушениях
  too1FaultDataAbort=3;                 // преждевременное прекращение данных о нарушениях
  too1FaultChannelRequest=8;            // запрос канала
  too1FaultChannelAbort=9;              // преждевременное прекращение канала
  too1FaultTagsRequest=16;              // запрос меток
  too1FaultTagsAbort=17;                // преждевременное прекращение меток
  too1FaultsListRequest=24;             // запрос списка зарегистрированных нарушений
  // для ASDU25
  too1FaultDataSuccess=64;              // данные о нарушениях переданы успешно (положительно)
  too1FaultDataFailed=65;               // данные о нарушениях переданы неуспешно (отрицательно)
  too1FaultChannelSucces=66;            // передача канала успешна (положительно)
  too1FaultChannelFailed=67;            // передача канала неуспешна (отрицательно)
  too1FaultTagsSuccess=68;              // метки переданы успешно (положительно)
  too1FaultTagsFailed=69;               // метки переданы неуспешно (отрицательно)
// для вторичной
  // для ASDU31
  too2FaultDataEnd=32;                  // окончание передачи данных о нарушениях без преждевременного прекращения
  too2FaultDataSystemAbort=33;          // окончание передачи данных о нарушениях с преждевременным прекращением системой управления
  too2FaultDataDeviceAbort=34;          // окончание передачи данных о нарушениях с преждевременным прекращением устройством защиты
  too2FaultChannelEnd=35;               // окончание передачи канала без преждевременного прекращения
  too2FaultChannelSystemAbort=36;       // окончание передачи канала с преждевременным прекращением системой управления
  too2FaultChannelDeviceAbort=37;       // окончание передачи канала с преждевременным прекращением устройством защиты
  too2FaultTagsEnd=38;                  // окончание передачи меток без преждевременного прекращения
  too2FaultTagsSystemAbort=39;          // окончание передачи меток с преждевременным прекращением системой управления
  too2FaultTagsDeviceAbort=40;          // окончание передачи меток с преждевременным прекращением устройством защиты

////////// константы типа аварийных значений
  tovInstantaneousValues=1;

type
  FCinfo=packed record
    _fc:integer;  // код функции управления
    _ft:integer;  // тип кадра
    _fcv:byte;    // значение бита FCV для этого кода, неизвестно (7) для _ft равного ftReserved и ftNotUsed
    _sDecription:PAnsiChar; // назначение функционального кода
  end;

const
  FCinfos1:array[0..15]of FCinfo=( // все коды для первичной станции
    (_fc: fc1ResetCommUnit;         _ft:ft1SendAck; _fcv: 0;          _sDecription:'сброс удалённого канала'),
    (_fc: 1;                        _ft:ftNotUsed;  _fcv: 0;          _sDecription:'сброс процесса пользователя'),
    (_fc: 2;                        _ft:ftReserved; _fcv: iUnused;    _sDecription:'резерв для балансной процедуры передачи'),
    (_fc: fc1UserSend;              _ft:ft1SendAck; _fcv: 1;          _sDecription:'пользовательские данные, подтверждение'),
    (_fc: fc1UserBroadcast;         _ft:ft1Req;     _fcv: 0;          _sDecription:'пользовательские данные, без ответа'),
    (_fc: 5;                        _ft:ftReserved; _fcv: iUnused;    _sDecription:'резерв'),
    (_fc: 6;                        _ft:ftReserved; _fcv: iUnused;    _sDecription:'резерв для использования по согласованию'),
    (_fc: fc1ResetFCB;              _ft:ft1SendAck; _fcv: 0;          _sDecription:'сброс FCB'),
    (_fc: 8;                        _ft:ftNotUsed;  _fcv: 0;          _sDecription:'запрос доступа'),
    (_fc: fc1ChannelState;          _ft:ft1ReqRes;  _fcv: 0;          _sDecription:'запрос о состоянии канала связи'),
    (_fc: fc1Class1;                _ft:ft1ReqRes;  _fcv: 1;          _sDecription:'запрос данных класса 1'),
    (_fc: fc1Class2;                _ft:ft1ReqRes;  _fcv: 1;          _sDecription:'запрос данных класса 2'),
    (_fc: 12;                       _ft:ftReserved; _fcv: iUnused;    _sDecription:'резерв'),
    (_fc: 13;                       _ft:ftReserved; _fcv: iUnused;    _sDecription:'резерв'),
    (_fc: 14;                       _ft:ftReserved; _fcv: iUnused;    _sDecription:'резерв для использования по согласованию'),
    (_fc: 15;                       _ft:ftReserved; _fcv: iUnused;    _sDecription:'резерв для использования по согласованию')
  );

  FCinfos2:array[0..15]of FCinfo=( // все коды для вторичной станции, _fcv не используется
    (_fc: fc2PosAck;                _ft:ft2Ack;     _fcv: iUnused;    _sDecription:'положительная квитанция'),
    (_fc: fc2NegAck;                _ft:ft2Ack;     _fcv: iUnused;    _sDecription:'отрицательная квитанция'),
    (_fc: 2;                        _ft:ftReserved; _fcv: iUnused;    _sDecription:'резерв'),
    (_fc: 3;                        _ft:ftReserved; _fcv: iUnused;    _sDecription:'резерв'),
    (_fc: 4;                        _ft:ftReserved; _fcv: iUnused;    _sDecription:'резерв'),
    (_fc: 5;                        _ft:ftReserved; _fcv: iUnused;    _sDecription:'резерв'),
    (_fc: 6;                        _ft:ftReserved; _fcv: iUnused;    _sDecription:'резерв для использования по согласованию'),
    (_fc: 7;                        _ft:ftReserved; _fcv: iUnused;    _sDecription:'резерв для использования по согласованию'),
    (_fc: fc2UserData;              _ft:ft2Res;     _fcv: iUnused;    _sDecription:'пользовательские данные присутствуют'),
    (_fc: fc2NoUserData;            _ft:ft2Res;     _fcv: iUnused;    _sDecription:'пользовательские данные отсутствуют, отрицательная квитанция'),
    (_fc: 10;                       _ft:ftReserved; _fcv: iUnused;    _sDecription:'резерв'),
    (_fc: fc2ChannelState;          _ft:ft2Res;     _fcv: iUnused;    _sDecription:'состояние канала связи или запрос доступа'),
    (_fc: 12;                       _ft:ftReserved; _fcv: iUnused;    _sDecription:'резерв'),
    (_fc: 13;                       _ft:ftReserved; _fcv: iUnused;    _sDecription:'резерв для использования по согласованию'),
    (_fc: fc2ServiceUnavailable;    _ft:ft2Res;     _fcv: iUnused;    _sDecription:'сервисные услуги не работают, есть неисправность'), // бит FCB должен поменяться
    (_fc: fc2ServiceUnimplemented;  _ft:ft2Res;     _fcv: iUnused;    _sDecription:'сервисные услуги не предусмотрены') // бит FCB должен поменяться
  );

  TIinfos1:array[0..6]of TIdentMapEntry=(
    (Value: ti1TimeSynchronization;               Name: 'синхронизация времени'),
    (Value: ti1GeneralInterrogation;              Name: 'общий опрос'),
    (Value: ti1GenericInfo;                       Name: 'групповая информация'),
    (Value: ti1GeneralCommand;                    Name: 'общая команда'),
    (Value: ti1GenericCommand;                    Name: 'групповая команда'),
    (Value: ti1FaultOrder;                        Name: 'приказ передачи данных о нарушениях (выбор нарушения, запрос/отмена передачи меток и данных аналоговых каналов)'),
    (Value: ti1FaultAcknowledge;                  Name: 'подтверждение передачи данных о нарушениях (положительное или отрицательное)')
  );

  TIinfos2:array[0..16]of TIdentMapEntry=(
    (Value: ti2TimeTag;                           Name: 'сообщение с меткой времени'),
    (Value: ti2RelativeTimeTag;                   Name: 'сообщение с меткой относительного времени'),
    (Value: ti2MeasuredValues1;                   Name: 'измеряемые величины, набор типа 1'),
    (Value: ti2ShortCircuitLocation;              Name: 'место короткого замыкания'),
    (Value: ti2IdentificationInfo;                Name: 'идентификационная информация'),
    (Value: ti2TimeSynchronization;               Name: 'синхронизация времени'),
    (Value: ti2GeneralInterrogationTermination;   Name: 'завершение общего опроса'),
    (Value: ti2MeasuredValues2;                   Name: 'измеряемые величины, набор типа 2'),
    (Value: ti2GenericInfo;                       Name: 'групповая информация'),
    (Value: ti2GenericIdentifier;                 Name: 'групповой идентификатор'),
    (Value: ti2FaultsList;                        Name: 'список зарегистрированных нарушений'),
    (Value: ti2FaultDataReady;                    Name: 'готовность к передаче данных о нарушениях'),
    (Value: ti2FaultChannelReady;                 Name: 'готовность к передаче данных аналогового канала'),
    (Value: ti2FaultTagsReady;                    Name: 'готовность к передаче меток'),
    (Value: ti2FaultTagsTransmission;             Name: 'передача аварийных значений'),
    (Value: ti2FaultValuesTransmission;           Name: 'передача меток'),
    (Value: ti2FaultTransmissionTermination;      Name: 'завершение передачи данных о нарушениях')
  );

  COTinfos1:array[0..5]of TIdentMapEntry=(
    (Value: cot1TimeSynchronization;              Name: 'синхронизация времени'),
    (Value: cot1GeneralInterrogation;             Name: 'инициализация общего опроса'),
    (Value: cot1GeneralCommand;                   Name: 'общая команда'),
    (Value: cot1FaultTransmission;                Name: 'передача данных о нарушениях'),
    (Value: cot1GenericWriteCommand;              Name: 'групповая команда записи'),
    (Value: cot1GenericReadCommand;               Name: 'групповая команда чтения')
  );

  COTinfos2:array[0..19]of TIdentMapEntry=(
    (Value: cot2Sporadic;                         Name: 'спорадическая'),
    (Value: cot2Cyclic;                           Name: 'циклическая'),
    (Value: cot2ResetFCB;                         Name: 'сброс бита счёта кадров FCB'),
    (Value: cot2ResetCommUnit;                    Name: 'сброс подсистемы связи CU'),
    (Value: cot2StartRestart;                     Name: 'старт/рестарт'),
    (Value: cot2PowerOn;                          Name: 'включение питания'),
    (Value: cot2TestMode;                         Name: 'тестовый режим'),
    (Value: cot2TimeSynchronization;              Name: 'синхронизация времени'),
    (Value: cot2GeneralInterrogation;             Name: 'общий опрос'),
    (Value: cot2GeneralInterrogationTermination;  Name: 'завершение общего опроса'),
    (Value: cot2LocalOperation;                   Name: 'местная операция'),
    (Value: cot2RemoteOperation;                  Name: 'удалённая операция'),
    (Value: cot2GeneralCommandPosAck;             Name: 'положительное подтверждение команды'),
    (Value: cot2GeneralCommandNegAck;             Name: 'отрицательное подтверждение команды'),
    (Value: cot2FaultDataTransmission;            Name: 'передача данных о неисправностях'),
    (Value: cot2GenericWriteCommandPosAck;        Name: 'положительное подтверждение групповой команды записи'),
    (Value: cot2GenericWriteCommandNegAck;        Name: 'отрицательное подтверждение групповой команды записи'),
    (Value: cot2GenericReadCommandValid;          Name: 'ответ правильными данными на групповую команду чтения'),
    (Value: cot2GenericReadCommandNotValid;       Name: 'ответ на групповую команду чтения данными, среди которых могут быть неправильные'),
    (Value: cot2GenericWriteAck;                  Name: 'подтверждение групповой записи')
  );

  TOOinfos1:array[0..13]of TIdentMapEntry=(
  // для ASDU24
    (Value: too1FaultSelect;                      Name: 'выбор повреждения'),
    (Value: too1FaultDataRequest;                 Name: 'запрос данных о нарушениях'),
    (Value: too1FaultDataAbort;                   Name: 'преждевременное прекращение данных о нарушениях'),
    (Value: too1FaultChannelRequest;              Name: 'запрос канала'),
    (Value: too1FaultChannelAbort;                Name: 'преждевременное прекращение канала'),
    (Value: too1FaultTagsRequest;                 Name: 'запрос меток'),
    (Value: too1FaultTagsAbort;                   Name: 'преждевременное прекращение меток'),
    (Value: too1FaultsListRequest;                Name: 'запрос списка зарегистрированных нарушений'),
  // для ASDU25
    (Value: too1FaultDataSuccess;                 Name: 'данные о нарушениях переданы успешно (положительно)'),
    (Value: too1FaultDataFailed;                  Name: 'данные о нарушениях переданы неуспешно (отрицательно)'),
    (Value: too1FaultChannelSucces;               Name: 'передача канала успешна (положительно)'),
    (Value: too1FaultChannelFailed;               Name: 'передача канала неуспешна (отрицательно)'),
    (Value: too1FaultTagsSuccess;                 Name: 'метки переданы успешно (положительно)'),
    (Value: too1FaultTagsFailed;                  Name: 'метки переданы неуспешно (отрицательно)')
  );

  TOOinfos2:array[0..8]of TIdentMapEntry=(
  // для ASDU31
    (Value: too2FaultDataEnd;                     Name: 'окончание передачи данных о нарушениях без преждевременного прекращения'),
    (Value: too2FaultDataSystemAbort;             Name: 'окончание передачи данных о нарушениях с преждевременным прекращением системой управления'),
    (Value: too2FaultDataDeviceAbort;             Name: 'окончание передачи данных о нарушениях с преждевременным прекращением устройством защиты'),
    (Value: too2FaultChannelEnd;                  Name: 'окончание передачи канала без преждевременного прекращения'),
    (Value: too2FaultChannelSystemAbort;          Name: 'окончание передачи канала с преждевременным прекращением системой управления'),
    (Value: too2FaultChannelDeviceAbort;          Name: 'окончание передачи канала с преждевременным прекращением устройством защиты'),
    (Value: too2FaultTagsEnd;                     Name: 'окончание передачи меток без преждевременного прекращения'),
    (Value: too2FaultTagsSystemAbort;             Name: 'окончание передачи меток с преждевременным прекращением системой управления'),
    (Value: too2FaultTagsDeviceAbort;             Name: 'окончание передачи меток с преждевременным прекращением устройством защиты')
  );

type
////////// типы IEC
  tagBIT=0..1;    // 1битная информация
  tag1BIT=tagBIT; // 1битная информация
  tag2BIT=0..3;   // 2битная информация
  tag4BIT=0..15;  // 4битная информация

// 7.2.6.1 Текущий канал
// ACC:=UI8[1..8]<1..255>
// байт указывает текущий канал, который должен обрабатываться при передаче данных о нарушениях, где
// 0 - глобальный, используется только в ASDU 24, 25 и 31, если данные канала не должны передаваться
// 1..8 - Ia, Ib, Ic, In, Vae, Vbe, Vce, Ven
// 9..63 - резерв для дальнейших совместимых определений
// 64..255 - резерв для частного использования
  tagACC=byte;

// 7.2.6.2 Символ ASCII
// ASC:=UI8[1..8]<ASCII 8битный код>
  tagASC=AnsiChar;

// 7.2.6.3 Уровень совместимости
// COL:=UI8[1..8]<0..255>
// Уровень совместимости устройства защиты, основанного на требованиях стандарта,
// равен 2 - без использования групповых услуг, 3 - с использованием групповых услуг
  tagCOL=byte;

// 7.2.6.4 Двухпозиционная команда
// DCO:=UI[1..2]<0..3>
// 0 - не используется, 1 - ОТКЛ, 2 - ВКЛ, 3 - не используется
  tagDCO=0..3;

// 7.2.6.5 Двухэлементная информация
// DPI:=UI[1..2]<0..3>
// 0 - не используется, 1 - ОТКЛ, 2 - ВКЛ, 3 - не используется
  tagDPI=0..3;

// 7.2.6.6 Номер повреждения
// FAN:=UI16[1..16]<1..65535>
// Номер повреждения используется для опознавания события, связанного с функциями защиты, например, сигнал запуска от устройства
// защиты увеличивает номер повреждения. Это значит, что последовательность с неуспешным АПВ будет регистрироваться как два отдельных
// повреждения со своими номерами. Номер повреждения не нужно ни сбрасывать, ни предварительно устанавливать.
  tagFAN=word;

// 7.2.6.7 Интервал между элементами информации
// INT:=UI16[1..16]<1..65535>
// Интервал сбора одиночных элементов информации должен быть одинаковым для всех данных о нарушениях. Указывается в микросекундах.
  tagINT=word;

// 7.2.6.8 Измеряемая величина с описателем качества
// MEA:=CP16{OV,ER,RES,MVAL}, где
// OV:=BS1[1]<0..1>   0 - нет переполнения,           1 - переполнение
// ER:=BS1[2]<0..1>   0 - MVAL правильное значение,   1 - MVAL неправильное значение
// RES:=BS1[3]<0..1>  не используется, всегда 0
// MVAL:=F13[4..16]<-1..+1-2**(-12)>
// В случае переполнения MVAL устанавливается его максимальное положительное или отрицательное значение в дополнение к OV:=1.
// Максимальное значение MVAL должно быть +-1.2 или +-2.4 номинального.
// Другие форматы и диапазоны могут использоваться с групповыми услугами.
  tagMEA=word; // для доступа к битам использовать TMEA(@varMEA).OV, TMEA(@varMEA).ER
  PtagMEA=^tagMEA; // указатель на тип tagMEA

// 7.2.6.9 Номер первого элемента информации в ASDU
// NFE:=UI16[1..16]<0..65535>
// Все одиночные значения данных о нарушении в канале (файле) имеют последовательные номера и передаются однородными частями.
// В составе ASDU они передаются с последовательно возрастающими номерами. Для того, чтобы иметь возможность правильно восстановить файл,
// указывается номер первого аварийного значения (первого элемента информации) в ASDU
  tagNFE=word;

// 7.2.6.10 Число каналов
// NOC:=UI8[1..8]<0..255>
// Этот байт показывает число аналоговых каналов набора передаваемых данных, готовых к передаче.
  tagNOC=byte;

// 7.2.6.11 Число элементов информации в канале
// NOE:=UI16[1..16]<1..65535>
// Все каналы содерждат одинаковое число элементов информации.
// Это число передаётся в ASDU26 "готовность к передаче данных о нарушениях" и справедливо для всех каналов.
  tagNOE=word;

// 7.2.6.12 Номер повреждения сети
// NOF:=UI16[1..16]<1..65535>
// Повреждение сети, например, короткое замыкание, может вызвать несколько аварийных событий с отключением и последующим АПВ,
// каждое из которых идентифицируется увеличением номера повреждения FAN. В этом случае номер повреждения сети остаётся неизменным,
// общим для этих событий. Номер повреждения сети не требуется ни сбрасывать, ни предварительно устанавливать.
  tagNOF=word;

// 7.2.6.13 Число меток
// NOT:=UI8[1..8]<0..255>
// Этот байт показывает число меток, передаваемых в ASDU29
  tagNOT=byte;

// 7.2.6.14 Число аварийных значений в ASDU30
// NDV:=UI8[1..8]<0..255>
  tagNDV=byte;

// 7.2.6.15 Относительное время
// RET:=UI16[1..16]<1..65535>
// Относительное время устанавливается в 0 в начале короткого замыкания. Оно указывает время в мс от запуска устройства защиты до текущего момента.
  tagRET=word;

// 7.2.6.16 Масштабный коэффициент
// RFA:=R32.23 {мантисса, порядок, знак}
// Значения аварийных данных передаются как относительные значения в формате чисел с фиксированной запятой.
// Масштабный коэффициент показывает соотношение между относительными и вторичными значениями.
//
//                                относительное значение
// Масштабный коэффициент RFA =  _________________________
//                                  вторичное значение
//
// Первичное значение равно вторичному значению, умноженному на отношение номинального первичного значения
// к номинальному вторичному значению:
//
//                                             номинальное первичное значение        относительное значение      номинальное первичное значение
// Первичное значение = вторичное значение X ___________________________________ = _________________________ X __________________________________
//                                             номинальное вторичное значение        масштабный коэффициент      номинальное вторичное значение
//
  tagRFA=Single;

// 7.2.6.17 Номинальное первичное значение
// RPV:=R32.23 {мантисса, порядок, знак}
  tagRPV=Single;

// 7.2.6.18 Номинальное вторичное значение
// RPV:=R32.23 {мантисса, порядок, знак}
  tagRSV=Single;

// 7.2.6.20 Расстояние до места короткого замыкания
// SCL:=R32.23 {мантисса, порядок, знак}
// Расстояние до места короткого замыкания представляется в форме реактивного сопротивления, приведённого к первичным значениям. Оно выражается в омах.
  tagSCL=Single;

// 7.2.6.21 Номер опроса
// SCN:=UI8[1..8]<0..255>
  tagSCN=byte;

// 7.2.6.22 Одиночное аварийное значение
// SDV:=F16[1..16]<-1+1-2**(-15)>
  tagSDV=SmallInt;

// 7.2.6.23 Дополнительная информация
// SIN:=UI8[1..8]<0.255>
// Дополнительная информация используется следующим образом:
// Причина передачи                                         SIN
// общий опрос                                              НОМЕР ОПРОСА ASDU, инициирующего GI
// положительное или отрицательное подтверждение команды    ИДЕНТИФИКАТОР ВОЗВРАЩАЕМОЙ ИНФОРМАЦИИ командного сообщения
// другая                                                   несущественно
  tagSIN=byte;

// 7.2.6.24 Состояние повреждения
// SOF:=BS8{TP,TM,TEST,OTEV,RES}, где
// TP:=BS1[1],    0 - регистрация повреждения без отключения, 1 - с отключением
// TM:=BS1[2],    0 - данные о нарушении, ожидающие передачи, 1 - передаваемые в данный момент
// TEST:=BS1[3],  0 - данные о нарушении, регистрируемые в рабочем режиме, 1 - в тестовом
// OTEV:=BS1[4],  0 - регистрация данных о нарушении, инициируемая запуском защиты, 1 - другими событиями
// RES:=BS4[5..8] - не используется
  tagSOF=byte;
  PtagSOF=^tagSOF;

// 7.2.6.25 Положение метки
// TAP:=UI16[1..16]<1..65535>
// Эти два байта показывают положение метки внутри набора данных о нарушении. Это число есть расстояние метки от первого
// элемента в наборе данных о нарушении, закодированное как число элементов информации по модулю 65536. Положение первой
// метки равно нулю.
  tagTAP=word;

// 7.2.6.26 Тип приказа
// TOO:=UI8[1..8]<0..255>
// ASDU24 (приказ о передаче данных о нарушениях) - <1..31>,
// ASDU32 (окончание передачи данных о нарушениях) - <32..63>,
// ASDU25 (подтверждение передачи данных о нарушениях) - <64..95>
//
// 1: выбор подтверждения;  2: запрос данных о нарушениях;  3: преждевременное прекращение данных о нарушениях;
// 4..7: резерв
// 8: запрос канала;        9: преждевременное прекращение канала;
// 10..15: резерв
// 16: запрос меток;        17: преждевременное прекращение меток
// 18..23: резерв
// 24: запрос списка зарегистрированных нарушений
// 25..31: резерв
//
// 32: окончание передачи данных о нарушениях без преждевременного прекращения
// 33: окончание передачи данных о нарушениях с преждевременным прекращением системой управления
// 34: окончание передачи данных о нарушениях с преждевременным прекращением устройством защиты
// 35: окончание передачи канала без преждевременного прекращения
// 36: окончание передачи канала с преждевременным прекращением системой управления
// 37: окончание передачи канала с преждевременным прекращением устройством защиты
// 38: окончание передачи меток без преждевременного прекращения
// 39: окончание передачи меток с преждевременным прекращением системой управления
// 40: окончание передачи меток с преждевременным прекращением устройством защиты
// 41..63: резерв
//
// 64: данные о нарушениях переданы успешно (положительно)
// 65: данные о нарушениях переданы безуспешно (отрицательно)
// 66: передача канала успешна (положительно)
// 67: передача канала неуспешна (отрицательно)
// 68: метки переданы успешно (положительно)
// 69: метки переданы неуспешно (отрицательно)
// 70..255: резерв
  tagTOO=byte;

// 7.2.6.27 Тип аварийных значений
// TOV:=UI8[1..8]<0..255>
// 0 - не используется, 1 - мгновенные значения, 2..255 - не используется
  tagTOV=byte;

// 7.2.6.28 Четыре байта времени в двоичном коде
// CP32Time2a:=CP{Миллисекунды,Минуты,RES1,Недостоверное значение,Часы,RES2,Летнее время}
// Используется для метки времени
  tagCP32Time2a=LongWord;
  PtagCP32Time2a=^tagCP32Time2a;

// 7.2.6.29 Семь байт времени в двоичном коде
// CP56Time2a:=CP56{Миллисекунды,Минуты,RES,Недостоверное значение,Часы,RES2,Летнее время,День месяца,День недели,Месяц,RES4,Год,RES4}
// Этот формат определён в МЭК 60870-5-4, подпункт 6.8. Он используется для синхронизации часов и в списке зарегистрированных данных о нарушениях.
// День недели устанавливают числами от 1 до 7, если используется, где 1 означает понедельник, при неиспользовании он устанавливается в ноль.
// Когда этот формат используется групповыми услугами, он может быть сокращён отбрасыванием старших байтов. DataSize определяет фактическое число байт.
  tagCP56Time2a=array[0..6]of byte;
  PtagCP56Time2a=^tagCP56Time2a;

  TrInformationObject1=packed record // ASDU1, для вторичной
    _FunctionType:byte;           // тип функции
    _InformationNumber:byte;      // номер информации
    _DPI:tagDPI;                  // двухэлементная информация
    _Time32:tagCP32Time2a;        // метка времени
    _SIN:tagSIN;                  // дополнительная информация
  end;

  TrInformationObject2=packed record // ASDU2, для вторичной
    _FunctionType:byte;           // тип функции
    _InformationNumber:byte;      // номер информации
    _DPI:tagDPI;                  // двухэлементная информация
    _RET:tagRET;                  // относительное время, для общего опроса не существенно
    _FAN:tagFAN;                  // номер повреждения, для общего опроса не существенно
    _Time32:tagCP32Time2a;        // метка времени
    _SIN:tagSIN;                  // дополнительная информация
  end;

  TrInformationObject3=packed record // ASDU3, для вторичной
    _FunctionType:byte;           // тип функции
    _InformationNumber:byte;      // номер информации
    _MEA:array[0..255]of tagMEA;  // массив измеряемых величин с описателем качества, количество величин - _VSQ and 0x7F
  end;

  TrInformationObject4=packed record // ASDU4, для вторичной
    _FunctionType:byte;           // тип функции
    _InformationNumber:byte;      // номер информации
    _SCL:tagSCL;                  // расстояние до места короткого замыкания
    _RET:tagRET;                  // относительное время
    _FAN:tagFAN;                  // номер повреждения
    _Time32:tagCP32Time2a;        // метка времени
  end;

  TrInformationObject5=packed record // ASDU5, для вторичной
    _FunctionType:byte;           // тип функции
    _InformationNumber:byte;      // номер информации
                  // 2 при cot2ResetFCB, 3 при cot2ResetCommUnit, 4 при cot2StartRestart=5, 5 при cot2PowerOn
    _COL:tagCOL;                  // уровень совместимости
    _Vendor:array[0..7]of tagASC; // производитель
    _SoftwareID:longword;         // идентификатор программного обеспечения (4 байта)
  end;

  TrInformationObject6=packed record // ASDU6, для первичной и вторичной
    _FunctionType:byte;           // тип функции          = 255
    _InformationNumber:byte;      // номер информации     = 0
    _Time56:tagCP56Time2a;        // время
  end;

  TrInformationObject7=packed record // ASDU7, для первичной
    _FunctionType:byte;           // тип функции          = 255
    _InformationNumber:byte;      // номер информации     = 0
    _SCN:tagSCN;                  // номер опроса
  end;

  TrInformationObject8=packed record // ASDU8, для вторичной
    _FunctionType:byte;           // тип функции          = 255
    _InformationNumber:byte;      // номер информации     = 0
    _SCN:tagSCN;                  // номер опроса, берётся из команды инициализации GI
  end;

  TrInformationObject9=packed record // ASDU9, для вторичной
    _FunctionType:byte;           // тип функции
    _InformationNumber:byte;      // номер информации
    _MEA:array[0..255]of tagMEA;  // массив измеряемых величин с описателем качества, количество величин - _VSQ and 0x7F
  end;

  TrFanInfo=packed record // описание повреждения для ASDU 23
    _FAN:tagFAN;                  // номер повреждения
    _SOF:tagSOF;                  // состояние повреждения
    _Time56:tagCP56Time2a;        // время
  end;

  TrInformationObject23=packed record // ASDU 23, для вторичной
    _FunctionType:byte;           // тип функции
    _InformationNumber:byte;      // номер информации, не используется и равен 0
    _FanInfo:array[0..255]of TrFanInfo; // массив описаний повреждения
  end;

  TrInformationObject24=packed record // ASDU24, для первичной
    _FunctionType:byte;           // тип функции
    _InformationNumber:byte;      // номер информации, не используется и равен 0
    _TOO:tagTOO;                  // тип приказа
    _TOV:tagTOV;                  // тип аварийных значений, определено только tovInstantaneousValues=1
    _FAN:tagFAN;                  // номер повреждения
    _ACC:tagACC;                  // текущий канал данных
  end;

  TrInformationObject25=packed record // ASDU25, для первичной
    _FunctionType:byte;           // тип функции
    _InformationNumber:byte;      // номер информации, не используется и равен 0
    _TOO:tagTOO;                  // тип приказа
    _TOV:tagTOV;                  // тип аварийных значений, определено только tovInstantaneousValues=1
    _FAN:tagFAN;                  // номер повреждения
    _ACC:tagACC;                  // текущий канал данных
  end;

  TrInformationObject26=packed record // ASDU26, для вторичной
    _FunctionType:byte;           // тип функции
    _InformationNumber:byte;      // номер информации, не используется и равен 0
    _NotUsed:byte;                // не используется и равен 0
    _TOV:tagTOV;                  // тип аварийных значений, определено только tovInstantaneousValues=1
    _FAN:tagFAN;                  // номер повреждения
    _NOF:tagNOF;                  // номер повреждения сети
    _NOC:tagNOC;                  // число каналов
    _NOE:tagNOE;                  // число элементов информации в канале
    _INT:tagINT;                  // интервал между элементами информации в мкс
    _Time32:tagCP32Time2a;        // метка времени первой зарегистрированной информации
  end;

  TrInformationObject27=packed record // ASDU27, для вторичной
    _FunctionType:byte;           // тип функции
    _InformationNumber:byte;      // номер информации, не используется и равен 0
    _NotUsed:byte;                // не используется и равен 0
    _TOV:tagTOV;                  // тип аварийных значений, определено только tovInstantaneousValues=1
    _FAN:tagFAN;                  // номер повреждения
    _ACC:tagACC;                  // текущий канал данных
    _RPV:tagRPV;                  // номинальное первичное значение
    _RSV:tagRSV;                  // номинальное вторичное значение
    _RFA:tagRFA;                  // масштабный коэффициент
  end;

  TrInformationObject28=packed record // ASDU28, для вторичной
    _FunctionType:byte;           // тип функции
    _InformationNumber:byte;      // номер информации, не используется и равен 0
    _NotUsed1:byte;               // не используется и равен 0
    _NotUsed2:byte;               // не используется и равен 0
    _FAN:tagFAN;                  // номер повреждения
  end;

  TrTagInfo=packed record // описание метки для ASDU29
    _FunctionType:byte;           // тип функции
    _InformationNumber:byte;      // номер информации
    _DPI:tagDPI;                  // состояние метки
  end;

  TrInformationObject29=packed record // ASDU29, для вторичной
    _FunctionType:byte;           // тип функции
    _InformationNumber:byte;      // номер информации, не используется и равен 0
    _FAN:tagFAN;                  // номер повреждения
    _NOT:tagNOT;                  // число меток в этом ASDU
    _TAP:tagTAP;                  // положение метки
    _Tags:array[0..255]of TrTagInfo; // массив меток
  end;

  TrInformationObject30=packed record // ASDU30, для вторичной
    _FunctionType:byte;           // тип функции
    _InformationNumber:byte;      // номер информации, не используется и равен 0
    _NotUsed:byte;                // не используется и равен 0
    _TOV:tagTOV;                  // тип аварийных значений, определено только tovInstantaneousValues=1
    _FAN:tagFAN;                  // номер повреждения
    _ACC:tagACC;                  // текущий канал данных
    _NDV:tagNDV;                  // число аварийных значений в этом ASDU
    _NFE:tagNFE;                  // номер первого элемента в этом ASDU
    _SDVs:array[0..255]of tagSDV; // массив аварийных значений
  end;

  TrInformationObject31=packed record // ASDU31, для вторичной
    _FunctionType:byte;           // тип функции
    _InformationNumber:byte;      // номер информации, не используется и равен 0
    _TOO:tagTOO;                  // тип приказа
    _TOV:tagTOV;                  // тип аварийных значений, определено только tovInstantaneousValues=1
    _FAN:tagFAN;                  // номер повреждения
    _ACC:tagACC;                  // текущий канал данных
  end;

  TrDataUnitIdentifier=packed record
    _TypeID:byte;       // идентификатор типа Type Identification
    _VSQ:byte;          // классификатор переменной структуры Variable Structure Qualifier
    _COT:byte;          // причина передачи Cause Of Transmission
    _ASDUAddress:byte;  // общий адрес ASDU
  end;

  TASDU=packed record //  Application Service Data Unit
  // Data Unit Identifier
    DUI:TrDataUnitIdentifier;
  // Information Object
    case integer of
      0: (FunctionType:byte; {тип функции} InformationNumber:byte {номер информации});
      1: (IO1:TrInformationObject1);    // для вторичной станции
      2: (IO2:TrInformationObject2);    // для вторичной станции
      3: (IO3:TrInformationObject3);    // для вторичной станции
      4: (IO4:TrInformationObject4);    // для вторичной станции
      5: (IO5:TrInformationObject5);    // для вторичной станции
      6: (IO6:TrInformationObject6);    // для первичной и вторичной станции - синхронизация
      7: (IO7:TrInformationObject7);    // для первичной станции - инициализация общего опроса
      8: (IO8:TrInformationObject8);    // для вторичной станции - окончание общего опроса
      9: (IO9:TrInformationObject9);    // для вторичной станции -
      23: (IO23:TrInformationObject23); // для вторичной станции - список нарушений
      24: (IO24:TrInformationObject24); // для первичной станции - приказ для нарушений
      25: (IO25:TrInformationObject25); // для первичной станции - подтверждение передачи данных о нарушениях
      26: (IO26:TrInformationObject26); // для вторичной станции - готовность к передаче данных о нарушениях
      27: (IO27:TrInformationObject27); // для вторичной станции - готовность к передаче канала
      28: (IO28:TrInformationObject28); // для вторичной станции - готовность к передаче меток
      29: (IO29:TrInformationObject29); // для вторичной станции - передача меток
      30: (IO30:TrInformationObject30); // для вторичной станции - передача аварийных значений
      31: (IO31:TrInformationObject31); // для вторичной станции - завершение передачи меток, данных канала, данных нарушения
  end;

  PLDU=^TLDU;
  TLDU=packed record  // Link Data Unit
    _LCF:byte;          // поле управления LinkControlField
    _LinkAddress:byte;  // адресс процесса связи
    _asdu:TASDU;        // ASDU
  end;

  EIEC103Types=class(Exception);

  TLinkControlField1=class // для первичной станции, использовать так TLinkControlField1(PByte).DFC
  private
    function GetBit(const ndx:integer):tagBIT;
    function GetFunctionCode:tag4BIT;
    procedure SetBit(const ndx:integer; const bit:tagBIT);
    procedure SetFunctionCode(const fc:tag4BIT);
  public
    property FunctionCode:tag4BIT read GetFunctionCode write SetFunctionCode;
    property FCV:tagBIT index ndxFCV read GetBit write SetBit;
    property FCB:tagBIT index ndxFCB read GetBit write SetBit;
    property PRM:tagBIT index ndxPRM read GetBit write SetBit;
    property RES:tagBIT index ndxRES read GetBit write SetBit;
  end;

  TLinkControlField2=class // для вторичной станции, использовать так TLinkControlField2(PByte).DFC
  private
    function GetBit(const ndx:integer):tagBIT;
    function GetFunctionCode:tag4BIT;
    procedure SetBit(const ndx:integer; const bit:tagBIT);
    procedure SetFunctionCode(const fc:tag4BIT);
  public
    property FunctionCode:tag4BIT read GetFunctionCode write SetFunctionCode;
    property DFC:tagBIT index ndxDFC read GetBit write SetBit;
    property ACD:tagBIT index ndxACD read GetBit write SetBit;
    property PRM:tagBIT index ndxPRM read GetBit write SetBit;
    property RES:tagBIT index ndxRES read GetBit write SetBit;
  end;

  TSOF=class // класс-помощник для типа tagSOF, использовать так - TSOF(PtagSOF).OTEV
  private
    function GetBit(const ndx:integer):tagBIT;
    function GetRes:tag4BIT;
    procedure SetBit(const ndx:integer; const bit:tagBIT);
    procedure SetRes(const value:tag4BIT);
  public
    property TP:tagBIT index ndxTP read GetBit write SetBit;      // регистрация повреждения с отключением или без
    property TM:tagBIT index ndxTM read GetBit write SetBit;      // данные о нарушении ожидающие передачи или передаваемые в настоящий момент
    property TEST:tagBIT index ndxTEST read GetBit write SetBit;  // данные о нарушении, регистрируемые в тестовом или рабочем режиме
    property OTEV:tagBIT index ndxOTEV read GetBit write SetBit;  // регистрация данных о нарушении, инициируемая запуском защиты или другими событиями
    property RES:tag4BIT read GetRes write SetRes;                // не используется
  end;

  TCP32Time2a=class // класс-помощник для типа tagCP32Time2a, использовать так - TCP32Time2a(PtagCP32Time2a).SU
  protected
    function GetBit(const ndx:integer):tagBIT;
    function GetRES2:tag2BIT;
    function GetWord(const ndx:integer):word;
    procedure SetBit(const ndx:integer; const Value:tagBIT);
    procedure SetRES2(const res2:tag2BIT);
    procedure SetWord(const ndx:integer; const Value:word);
  public
    property Milliseconds:word index ndxMilliseconds read GetWord write SetWord;  // миллисекунды 0..59999
    property Minutes:word index ndxMinutes read GetWord write SetWord;            // минуты 0..59
    property RES1:tagBIT index ndxRES1 read GetBit write SetBit;                  // резерв 1
    property IV:tagBIT index ndxIV read GetBit write SetBit;                      // недействительное значение
    property Hours:word index ndxHours read GetWord write SetWord;                // часы 0..23
    property RES2:tag2BIT read GetRES2 write SetRES2;                             // резерв 2
    property SU:tagBIT index ndxSU read GetBit write SetBit;
  end;

  TCP56Time2a=class // класс-помощник для типа tagCP56Time2a, использовать так - TCP56Time2a(PtagCP56Time2a).SU
  protected
    function GetBit(const ndx:integer):tagBIT;
    function GetRES2:tag2BIT;
    function GetRES3:tag4BIT;
    function GetWord(const ndx:integer):word;
    procedure SetBit(const ndx:integer; const Value:tagBIT);
    procedure SetRES2(const res2:tag2BIT);
    procedure SetRES3(const Value:tag4BIT);
    procedure SetWord(const ndx:integer; const Value:word);
  public
    property Milliseconds:word index ndxMilliseconds read GetWord write SetWord;  // миллисекунды 0..59999
    property Minutes:word index ndxMinutes read GetWord write SetWord;            // минуты 0..59
    property RES1:tagBIT index ndxRES1 read GetBit write SetBit;                  // резерв 1
    property IV:tagBIT index ndxIV read GetBit write SetBit;                      // недействительное значение
    property Hours:word index ndxHours read GetWord write SetWord;                // часы 0..23
    property RES2:tag2BIT read GetRES2 write SetRES2;                             // резерв 2
    property SU:tagBIT index ndxSU read GetBit write SetBit;
    property DayOfMonth:word index ndxDayOfMonth read GetWord write SetWord;      // день месяца 1..31
    property DayOfWeek:word index ndxDayOfWeek read GetWord write SetWord;        // день недели 1..7
    property Month:word index ndxMonth read GetWord write SetWord;                // месяц 1..12
    property RES3:tag4BIT read GetRES3 write SetRES3;                             // резерв 3
    property Year:word index ndxYear read GetWord write SetWord;                  // год 0..99
    property RES4:tagBIT index ndxRES4 read getBit write SetBit;                  // резерв 4
  end;

  TMEA=class // класс-помощник для типа tagMEA, использовать так - TMEA(PtagMEA).OV:=1
  private
    function GetER:tagBIT;
    function GetMVAL:Single;
    function GetOV:tagBIT;
    function GetRES:tagBIT;
    procedure SetER(const er:tagBIT);
    procedure SetMVAL(const mval:Single);
    procedure SetOV(const ov:tagBIT);
    procedure SetRES(const res:tagBIT);
  public
    property OV:tagBIT read GetOV write SetOV;        // признак переполнения
    property ER:tagBIT read GetER write SetER;        // признак правильности MVAL
    property RES:tagBIT read GetRES write SetRES;     // резервный бит
    property MVAL:Single read GetMVAL write SetMVAL;  // значение в диапазоне -1..+1-2**(-12)
  end;

  function CP32Time2aToStr(time32:tagCP32Time2a):AnsiString; // время tagCP32Time2a в виде строки
  function CP56Time2aToStr(time56:tagCP56Time2a):AnsiString; // время tagCP56Time2a в виде строки

  function LinkControlField(const ui8:byte):byte; // поле управления на основе бита PRM: бит RES,FCB/ACD не меняется,
                                                  // FCV устанавливается для первичного, а DFC не меняется

  function LinkControlField1(const ui8:byte):byte; // поле управления для первичной станции, PRM в 1
  function LinkControlField2(const ui8:byte):byte; // поле управления для вторичной станции, PRM в 0

  function FunctionCode1ToString(const fc:byte):AnsiString; // сервисный код функции в текст для первичного
  function FunctionCode2ToString(const fc:byte):AnsiString; // сервисный код функции в текст для вторичного

  function TypeIdentification1ToString(const ti:byte):AnsiString; // тип ASDU в текст для первичного
  function TypeIdentification2ToString(const ti:byte):AnsiString; // тип ASDU в текст для вторичного

  function CauseOfTransmission1ToString(const cot:byte):AnsiString; // причина передачи в текст для первичного
  function CauseOfTransmission2ToString(const cot:byte):AnsiString; // причина передачи в текст для первичного


implementation

uses Windows;

{$BOOLEVAL OFF}
{$RANGECHECKS OFF}
{$OVERFLOWCHECKS OFF}

  const arrSU:array[Boolean]of AnsiString=('',' SU'); arrIV:array[Boolean]of AnsiString=('',' IV');

  procedure DoException(s:AnsiString); begin raise EIEC103Types.Create(s); end;


  function CP32Time2aToStr(time32:tagCP32Time2a):AnsiString; begin
    with TCP32Time2a(@time32)do Result:=Format('%.2d:%.2d:%.2d.%.3d%s%s',[Hours,Minutes,
      Milliseconds div 1000,Milliseconds mod 1000,arrSU[SU=1],arrIV[IV=1]]);
  end;

  function CP56Time2aToStr(time56:tagCP56Time2a):AnsiString; var w:word; st:TSystemTime; begin
    GetSystemTime(st); w:=(st.wYear div 1000)*1000;
    with TCP56Time2a(@time56)do Result:=Format('%.4d.%.2d.%.2d %s',[w+Year,Month,DayOfMonth,CP32Time2aToStr(PtagCP32Time2a(@time56)^)]);
  end;

  function LinkControlField(const ui8:byte):byte; var fc:FCinfo; // поле управления на основе бита PRM:  бит RES,FCB/ACD не меняется,
  begin Result:=ui8;                                             // FCV устанавливается для первичного, а DFC не меняется
    if(ui8 and$40)<>0then begin // первичная станция
      fc:=FCinfos1[ui8 and$0F]; if fc._fcv<>iUnused then Result:=(Result and not$10)or(fc._fcv shl 4);
    end else fc:=FCinfos2[ui8 and$0F]; // вторичная станция
    if fc._ft=ftReserved then DoException(Format('сервисная функция %d для PRM=%d зарезервирована, в МЭК 60870-5-103 не используется',[fc._fc,ui8 and$40]))
    else if fc._ft=ftNotUsed then DoException(Format('сервисная функция %d для PRM=%d в МЭК 60870-5-103 не используется',[fc._fc,ui8 and$40]));
  end;

  function LinkControlField1(const ui8:byte):byte; // поле управления для первичной станции, PRM в 1
  begin Result:=LinkControlField(ui8 or$40); end;

  function LinkControlField2(const ui8:byte):byte; // поле управления для вторичной станции, PRM в 0
  begin Result:=LinkControlField(ui8 and not$40); end;

  function FunctionCode1ToString(const fc:byte):AnsiString; // сервисный код функции в текст для первичного
  begin Result:='0x'+IntToHex(fc and$0F,2)+' - '+FCinfos1[fc and$0F]._sDecription; end;

  function FunctionCode2ToString(const fc:byte):AnsiString; // сервисный код функции в текст для вторичного
  begin Result:='0x'+IntToHex(fc and$0F,2)+' - '+FCinfos2[fc and$0F]._sDecription; end;

  function TypeIdentification1ToString(const ti:byte):AnsiString; var s:AnsiString; begin // тип ASDU в текст для первичного
    if not IntToIdent(ti,s,TIinfos1)then
      if((ti)=0)or(ti>31)then s:='для специального применения (частный диапазон)'
      else s:='зарезервировано для будущих совместных применений';
    Result:='0x'+IntToHex(ti,2)+' - '+s;
  end;

  function TypeIdentification2ToString(const ti:byte):AnsiString; var s:AnsiString; begin // тип ASDU в текст для вторичного
    if not IntToIdent(ti,s,TIinfos2)then
      if((ti)=0)or(ti>31)then s:='для специального применения (частный диапазон)'
      else s:='зарезервировано для будущих совместных применений';
    Result:='0x'+IntToHex(ti,2)+' - '+s;
  end;

  function CauseOfTransmission1ToString(const cot:byte):AnsiString; var s:AnsiString; begin // причина передачи в текст для первичного
    if not IntToIdent(cot,s,COTinfos1)then
      if(cot>63)then s:='для специального применения (частный диапазон)'
      else s:='зарезервировано для будущих совместных применений';
    Result:='0x'+IntToHex(cot,2)+' - '+s;
  end;

  function CauseOfTransmission2ToString(const cot:byte):AnsiString; var s:AnsiString; begin // причина передачи в текст для первичного
    if not IntToIdent(cot,s,COTinfos2)then
      if(cot>63)then s:='для специального применения (частный диапазон)'
      else s:='зарезервировано для будущих совместных применений';
    Result:='0x'+IntToHex(cot,2)+' - '+s;
  end;

{ TLinkControlField1 }

function TLinkControlField1.GetBit(const ndx:integer):tagBIT; begin
  case ndx of
    ndxFCV: Result:=tagBIT((PByte(Self)^shr 4)and$01);
    ndxFCB: Result:=tagBIT((PByte(Self)^shr 5)and$01);
    ndxPRM: Result:=tagBIT((PByte(Self)^shr 6)and$01);
    ndxRES: Result:=tagBIT((PByte(Self)^shr 7)and$01);
  else Result:=0; end;
end;

function TLinkControlField1.GetFunctionCode:tag4BIT;
begin Result:=tag4BIT(PByte(Self)^and$0F); end;

procedure TLinkControlField1.SetBit(const ndx:integer; const bit:tagBIT); begin
  case ndx of
    ndxFCV: PByte(Self)^:=(PByte(Self)^and not$10)or(bit shl 4);
    ndxFCB: PByte(Self)^:=(PByte(Self)^and not$20)or(bit shl 5);
    ndxPRM: PByte(Self)^:=(PByte(Self)^and not$40)or(1 shl 6);
    ndxRES: PByte(Self)^:=(PByte(Self)^and not$80)or(bit shl 7);
  end;
end;

procedure TLinkControlField1.SetFunctionCode(const fc:tag4BIT);
begin PByte(Self)^:=(PByte(Self)^and not$0F)or fc; end;

{ TLinkControlField2 }

function TLinkControlField2.GetBit(const ndx:integer):tagBIT; begin
  case ndx of
    ndxDFC: Result:=tagBIT((PByte(Self)^shr 4)and$01);
    ndxACD: Result:=tagBIT((PByte(Self)^shr 5)and$01);
    ndxPRM: Result:=tagBIT((PByte(Self)^shr 6)and$01);
    ndxRES: Result:=tagBIT((PByte(Self)^shr 7)and$01);
  else Result:=0; end;
end;

function TLinkControlField2.GetFunctionCode:tag4BIT;
begin Result:=tag4BIT(PByte(Self)^and$0F); end;

procedure TLinkControlField2.SetBit(const ndx:integer; const bit:tagBIT); begin
  case ndx of
    ndxDFC: PByte(Self)^:=(PByte(Self)^and not$10)or(bit shl 4);
    ndxACD: PByte(Self)^:=(PByte(Self)^and not$20)or(bit shl 5);
    ndxPRM: PByte(Self)^:=(PByte(Self)^and not$40)or(1 shl 6);
    ndxRES: PByte(Self)^:=(PByte(Self)^and not$80)or(bit shl 7);
  end;
end;

procedure TLinkControlField2.SetFunctionCode(const fc:tag4BIT);
begin PByte(Self)^:=(PByte(Self)^and not$0F)or fc; end;

{ TSOF }

function TSOF.GetBit(const ndx:integer):tagBIT; begin
  case ndx of
    ndxTP:    Result:=tagBIT(PtagSOF(Self)^and$01);
    ndxTM:    Result:=tagBIT((PtagSOF(Self)^shr 1)and$01);
    ndxTEST:  Result:=tagBIT((PtagSOF(Self)^shr 2)and$01);
    ndxOTEV:  Result:=tagBIT((PtagSOF(Self)^shr 3)and$01);
  else Result:=0; end;
end;

function TSOF.GetRes: tag4BIT;
begin Result:=tag4BIT(PtagSOF(Self)^shr 4); end;

procedure TSOF.SetBit(const ndx:integer; const bit:tagBIT); begin
  case ndx of
    ndxTP:    PtagSOF(Self)^:=tagSOF((PtagSOF(Self)^and not$01)or(bit)); 
    ndxTM:    PtagSOF(Self)^:=tagSOF((PtagSOF(Self)^and not$02)or(bit shl 1));
    ndxTEST:  PtagSOF(Self)^:=tagSOF((PtagSOF(Self)^and not$04)or(bit shl 2));
    ndxOTEV:  PtagSOF(Self)^:=tagSOF((PtagSOF(Self)^and not$08)or(bit shl 3));
  end;
end;

procedure TSOF.SetRes(const value:tag4BIT);
begin PtagSOF(Self)^:=tagSOF((PtagSOF(Self)^and$0F)and(value shl 4)); end;

{ TCP32Time2a }

function TCP32Time2a.GetBit(const ndx:integer):tagBIT; begin
  case ndx of
    ndxRES1:  Result:=tagBIT((PtagCP32Time2a(Self)^shr 22)and$01);
    ndxIV:    Result:=tagBIT((PtagCP32Time2a(Self)^shr 23)and$01);
    ndxSU:    Result:=tagBIT((PtagCP32Time2a(Self)^shr 31)and$01);
  else Result:=0; end;
end;

function TCP32Time2a.GetRES2:tag2BIT;
begin Result:=tag2BIT((PtagCP32Time2a(Self)^shr 29)and$03); end;

function TCP32Time2a.GetWord(const ndx:integer):word; begin
  case ndx of
    ndxMilliseconds:  Result:=word(PtagCP32Time2a(Self)^);
    ndxMinutes:       Result:=word((PtagCP32Time2a(Self)^shr 16)and$3F);
    ndxHours:         Result:=word((PtagCP32Time2a(Self)^shr 24)and$1F);
  else Result:=0; end;
end;

procedure TCP32Time2a.SetBit(const ndx:integer; const Value:tagBIT); begin
  case ndx of
    ndxRES1:  PtagCP32Time2a(Self)^:=tagCP32Time2a((PtagCP32Time2a(Self)^and not$00400000)or(Value shl 22));
    ndxIV:    PtagCP32Time2a(Self)^:=tagCP32Time2a((PtagCP32Time2a(Self)^and not$00800000)or(Value shl 23));
    ndxSU:    PtagCP32Time2a(Self)^:=tagCP32Time2a((PtagCP32Time2a(Self)^and not$80000000)or(Value shl 31));
  end;
end;

procedure TCP32Time2a.SetRES2(const res2:tag2BIT);
begin PtagCP32Time2a(Self)^:=tagCP32Time2a((PtagCP32Time2a(Self)^and not$60000000)or(res2 shl 29)); end;

procedure TCP32Time2a.SetWord(const ndx:integer; const Value:word); begin
  case ndx of
    ndxMilliseconds:  begin if Value>59999then IV:=1;
      PtagCP32Time2a(Self)^:=tagCP32Time2a((PtagCP32Time2a(Self)^and not$FFFF)or(Value));
    end;
    ndxMinutes: begin if Value>59then IV:=1;
      PtagCP32Time2a(Self)^:=tagCP32Time2a((PtagCP32Time2a(Self)^and not$3F0000)or((Value and$3F)shl 16));
    end;
    ndxHours: begin if Value>23then IV:=1;
      PtagCP32Time2a(Self)^:=tagCP32Time2a((PtagCP32Time2a(Self)^and not$1F000000)or((Value and$1F)shl 24));
    end;
  end;
end;

{ TCP56Time2a }

function TCP56Time2a.GetBit(const ndx:integer):tagBIT; begin
  case ndx of
    ndxRES1:  Result:=tagBIT((PtagCP32Time2a(Self)^shr 22)and$01);
    ndxIV:    Result:=tagBIT((PtagCP32Time2a(Self)^shr 23)and$01);
    ndxSU:    Result:=tagBIT((PtagCP32Time2a(Self)^shr 31)and$01);
    ndxRES4:  Result:=tagBIT((PtagCP56Time2a(Self)^[6]shl 7)and$01);
  else Result:=0; end;
end;

function TCP56Time2a.GetRES2:tag2BIT;
begin Result:=tag2BIT((PtagCP32Time2a(Self)^shr 29)and$03); end;

function TCP56Time2a.GetRES3:tag4BIT;
begin Result:=tag4BIT((PtagCP56Time2a(Self)^[5]shr 4)and$0F); end;

function TCP56Time2a.GetWord(const ndx:integer):word; begin
  case ndx of
    ndxMilliseconds:  Result:=word(PtagCP32Time2a(Self)^);
    ndxMinutes:       Result:=word((PtagCP32Time2a(Self)^shr 16)and$3F);
    ndxHours:         Result:=word((PtagCP32Time2a(Self)^shr 24)and$1F);
    ndxDayOfMonth:    Result:=word(PtagCP56Time2a(Self)^[4]and$1F);
    ndxDayOfWeek:     Result:=word((PtagCP56Time2a(Self)^[4]shr 5)and$07);
    ndxMonth:         Result:=word(PtagCP56Time2a(Self)^[5]and$0F);
    ndxYear:          Result:=word(PtagCP56Time2a(Self)^[6]and$7F);
  else Result:=0; end;
end;

procedure TCP56Time2a.SetBit(const ndx:integer; const Value:tagBIT); begin
  case ndx of
    ndxRES1:  PtagCP32Time2a(Self)^:=tagCP32Time2a((PtagCP32Time2a(Self)^and not$00400000)or(Value shl 22));
    ndxIV:    PtagCP32Time2a(Self)^:=tagCP32Time2a((PtagCP32Time2a(Self)^and not$00800000)or(Value shl 23));
    ndxSU:    PtagCP32Time2a(Self)^:=tagCP32Time2a((PtagCP32Time2a(Self)^and not$80000000)or(Value shl 31));
    ndxRES4:  PtagCP56Time2a(Self)^[6]:=(PtagCP56Time2a(Self)^[6]and$7F)or(Value shl 7)
  end;
end;

procedure TCP56Time2a.SetRES2(const res2:tag2BIT);
begin PtagCP32Time2a(Self)^:=tagCP32Time2a((PtagCP32Time2a(Self)^and not$60000000)or(res2 shl 29)); end;

procedure TCP56Time2a.SetRES3(const Value:tag4BIT);
begin PtagCP56Time2a(Self)^[5]:=(PtagCP56Time2a(Self)^[5]and$F0)or(Value shl 4); end;

procedure TCP56Time2a.SetWord(const ndx:integer; const Value:word); begin
  case ndx of
    ndxMilliseconds:  begin if Value>59999then IV:=1;
      PtagCP32Time2a(Self)^:=tagCP32Time2a((PtagCP32Time2a(Self)^and not$FFFF)or(Value));
    end;
    ndxMinutes: begin if Value>59then IV:=1;
      PtagCP32Time2a(Self)^:=tagCP32Time2a((PtagCP32Time2a(Self)^and not$3F0000)or((Value and$3F)shl 16));
    end;
    ndxHours: begin if Value>23then IV:=1;
      PtagCP32Time2a(Self)^:=tagCP32Time2a((PtagCP32Time2a(Self)^and not$1F000000)or((Value and$1F)shl 24));
    end;
    ndxDayOfMonth: begin if(Value=0)or(Value>31)then IV:=1;
      PtagCP56Time2a(Self)^[4]:=(PtagCP56Time2a(Self)^[4]and byte(not$1F))or(Value and$1F);
    end;
    ndxDayOfWeek: begin if(Value>7)then IV:=1;
      PtagCP56Time2a(Self)^[4]:=(PtagCP56Time2a(Self)^[4]and byte(not$E0))or((Value and$07)shl 5);
    end;
    ndxMonth: begin if(Value=0)or(Value>12)then IV:=1;
      PtagCP56Time2a(Self)^[5]:=(PtagCP56Time2a(Self)^[5]and byte(not$0F))or(Value and$0F);
    end;
    ndxYear: begin
      PtagCP56Time2a(Self)^[6]:=(PtagCP56Time2a(Self)^[6]and byte(not$7F))or(Value mod 100);
    end;
  end;
end;

{ TMEA }

function TMEA.GetER:tagBIT;
begin Result:=tagBIT((PtagMEA(Self)^shr 1)and$01); end;

function TMEA.GetMVAL:Single;
begin Result:=(SmallInt(PtagMEA(Self)^))/$8000; end;

function TMEA.GetOV:tagBIT;
begin Result:=tagBIT(PtagMEA(Self)^and$01); end;

function TMEA.GetRES:tagBIT;
begin Result:=tagBIT((PtagMEA(Self)^shr 2)and$01); end;

procedure TMEA.SetER(const er:tagBIT);
begin PtagMEA(Self)^:=tagMEA((PtagMEA(Self)^and not$02)or(er shl 1)); end;

procedure TMEA.SetMVAL(const mval:Single); var s:single; begin
  if mval<-1then begin s:=-1; OV:=1; end
  else if mval>=1then begin s:=1-0.000244140625; OV:=1; end
    else begin s:=mval; OV:=0; end;
  PtagMEA(Self)^:=tagMEA((PtagMEA(Self)^and $07)or(Round(s*$1000)shl 3));
end;

procedure TMEA.SetOV(const ov:tagBIT);
begin PtagMEA(Self)^:=tagMEA((PtagMEA(Self)^and not$01)or(ov)); end;

procedure TMEA.SetRES(const res:tagBIT);
begin PtagMEA(Self)^:=tagMEA((PtagMEA(Self)^and not$08)or(res shl 2)); end;

end.
